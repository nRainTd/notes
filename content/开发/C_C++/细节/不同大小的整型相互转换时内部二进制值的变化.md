## 1 小变大

1. 负数：转化为相同十进制负数在该类型下的二进制值（不同大小的整型，相同十进制负数所对应的二进制值不一样。
2. 正数：直接赋值，不做转化。

## 2 大变小

1. 负数：转化为相同十进制负数在该类型下的二进制值（不同大小的整型，相同十进制负数所对应的二进制值不一样。
2. 正数：如果二进制值在小类型范围内，无论有没有符号，不做转化，直接赋值；最终有符号小类型的二进制值对应的十进制可能为负数。如果二进制值不在小类型范围内，则舍去高位，将低位直接赋值；同样的，有符号小类型对应的十进制可能是负数。（应为负数最高位为 1，整数最高位为 0，所以在二进制中负数排在整数后面。例如对于 int8_t , 二进制 0~127 为正数，二进制 128~255 为负数。

## 3 注

> 这里说的负数，是二进制数在对于的类型解析下对应是负数，而不是变量被赋值为负数就是负数。例如 `uint8_t a = -1;` ，这里的 a 的值其实是 255 ，是正数而不是负数。

> 无论接收的变量是有符号的还是无符号的，内部的二进制值都会按照上述规则转化。即使是一个无符号类型的变量接收一个其他有符号类型的负数，也会发生上述每条的序号一转化。

## 4 内部原理

实际上，就是小变大，高位填充 1(-) 或 0(+)；大变小，去掉高位而已。稍微思考验证一下，完美符合上面的规则。

## 5 疑问：char 变 long long
