头文件
```cpp
#include <iostream> 
#include <initializer_list>
```

`StaticNode` 类
```cpp
template <typename T, int SIZE>
class StaticLink;

template <typename T, int SIZE>
class StaticNode {
private:
  T data;
  int cur = 0;
public:
  friend class StaticLink<T, SIZE>;
};
```

`StaticLink` 类
```cpp
template <typename T, int SIZE>
class StaticLink {
private:
  StaticNode<T, SIZE> arr[SIZE];
  int zero_cur;
  int head_cur;
  int length = 0;

public: // 构造函数
  StaticLink() { initReserve(); }
  StaticLink(std::initializer_list<T> datas);

private: // 链表管理函数
  void initReserve();
  int mallocNodeCur();
  void freeById(int index) {
    auto node_to_be_free = accessNodeById(index);
    auto nodeCur_to_be_free = getNodeCurById(index);
    auto zero_curNode = accessNodeByCur(this->zero_cur);
    node_to_be_free->cur = zero_curNode->cur;
    zero_curNode->cur = nodeCur_to_be_free;
  }

public: // 重载下标运算符
  T& operator [] (int index) {
    return accessNodeById(index)->data;
  }
  const T& operator [] (int index) const {
    return getNodeById(index)->data;
  }

public: // CRUD 函数
  void del(int index);
  void insert(T data, int index);
  void push(T data) { insert(data, len()); }
  T pop() {
    auto data = accessNodeById(len() - 1)->data;
    del(len() - 1);
    return data;
  }
  void unshift(T data) { insert(data, 0); }
  T shift() {
    auto data = (*this)[0];
    del(0);
    return data;
  }
  void display() const;
  int len() const { return this->length; }

private: // 辅助函数
  int getNodeCurById(int index) const {
    if (index >= this->length) {
      std::cerr << "访问越界" << std::endl;
      exit(1);
    }
    if (index == -1) return this->head_cur;

    int cur = getDataCur();
    while (index--) { cur = this->arr[cur].cur; }
    return cur;
  }
  int getDataCur() const { return this->arr[this->head_cur].cur; }
  const StaticNode<T, SIZE>* getNodeByCur(int cur) const {
    return this->arr + cur;
  }
  const StaticNode<T, SIZE>* getNodeById(int index) const {
    int cur = getNodeCurById(index);
    return getNodeByCur(cur);
  }

private:
  StaticNode<T, SIZE>* accessNodeByCur(int cur) {
    return this->arr + cur;
  }
  StaticNode<T, SIZE>* accessNodeById(int index) {
    int cur = getNodeCurById(index);
    return accessNodeByCur(cur);
  }
};
```

类方法定义
```cpp
// 构造函数
template <typename T, int SIZE>
StaticLink<T, SIZE>::StaticLink(std::initializer_list<T> datas) {
  if (datas.size() > SIZE - 2) {
    std::cerr << "数据的数量超过大小" << std::endl;
    exit(1);
  }
  initReserve();
  this->head_cur = mallocNodeCur();
  this->arr[this->head_cur].cur = mallocNodeCur();

  auto p_tmp = accessNodeByCur(getDataCur());
  auto p_data = datas.begin();
  for (; p_data < datas.end() - 1; p_data++, p_tmp++, this->length++) {
    p_tmp->data = *p_data;
    p_tmp->cur = mallocNodeCur();
  }
  p_tmp->data = *p_data;
  p_tmp->cur = this->zero_cur;
  this->length++;
}

// 初始化备用链
template <typename T, int SIZE>
void StaticLink<T, SIZE>::initReserve() {
  this->zero_cur = 0;
  auto p_tmp = this->arr + this->zero_cur;
  for (int i = this->zero_cur + 1; i < SIZE - 1; i++) {
    p_tmp->cur = i;
    p_tmp++;
  }
  p_tmp->cur = 0;
}

// 分配一个节点
template <typename T, int SIZE>
int StaticLink<T, SIZE>::mallocNodeCur() {
  int i = this->arr[this->zero_cur].cur;
  if (i != this->zero_cur) {
    this->arr[this->zero_cur].cur = this->arr[i].cur;
    this->arr[i].cur = this->zero_cur;
    return i;
  } else {
    return this->zero_cur;
  }
}

// 删除
template <typename T, int SIZE>
void StaticLink<T, SIZE>::del(int index) {
  int next_cur;
  if (index == len() - 1)
    next_cur = this->zero_cur;
  else
    next_cur = getNodeCurById(index + 1);

  freeById(index);
  accessNodeById(index - 1)->cur = next_cur;
  this->length--;
}

// 插入
template <typename T, int SIZE>
void StaticLink<T, SIZE>::insert(T data, int index) {
  int new_cur = mallocNodeCur();
  if (new_cur == this->zero_cur) {
    std::cerr << "没有足够的空间" << std::endl;
    exit(1);
  }

  auto new_node = accessNodeByCur(new_cur);
  new_node->data = data;

  if (index == 0) {
    auto last_node_cur = getNodeCurById(0);
    accessNodeByCur(this->head_cur)->cur = new_cur;
    new_node->cur = last_node_cur;
  } else {
    auto last_node = accessNodeById(index - 1);
    new_node->cur = last_node->cur;
    last_node->cur = new_cur;
  }

  this->length++;
}

// 遍历输出
template <typename T, int SIZE>
void StaticLink<T, SIZE>::display() const {
  for (int i = 0; i < this->length; i++) {
    auto p_tmp = getNodeById(i);
    std::cout << p_tmp->data << ' ';
  }
  std::cout << std::endl;
}
```

在 `main` 函数中测试
```cpp
int main() {
  using namespace std;
  StaticLink<int, 20> list{ 1,2,3,4,5,6,7,8,9 };

  cout << "遍历输出:" << endl;
  list.display();

  cout << "把 6 改为 16" << endl;
  list[5] = 16;
  list.display();

  list.insert(11, 1);
  cout << "在 2 前面插入 11:" << endl;
  list.display();

  list.del(3);
  cout << "删除 3" << endl;
  list.display();

  list.push(11);
  cout << "push(11):" << endl;
  list.display();

  list.unshift(0);
  cout << "unshift(0):" << endl;
  list.display();

  auto last_data = list.pop();
  cout << "pop() = " << last_data << ':' << endl;
  list.display();

  auto first_data = list.shift();
  cout << "shift() = " << first_data << ':' << endl;
  list.display();

  return 0;
}
```

输出结果
```bash
遍历输出:
1 2 3 4 5 6 7 8 9 
把 6 改为 16
1 2 3 4 5 16 7 8 9 
在 2 前面插入 11:
1 11 2 3 4 5 16 7 8 9
删除 3
1 11 2 4 5 16 7 8 9
push(11):
1 11 2 4 5 16 7 8 9 11
unshift(0):
0 1 11 2 4 5 16 7 8 9 11
pop() = 11:
0 1 11 2 4 5 16 7 8 9
shift() = 0:
1 11 2 4 5 16 7 8 9
```
