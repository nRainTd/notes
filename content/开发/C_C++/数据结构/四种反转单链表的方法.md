
```toc
```

## 1 类的改进  

之前我使用一个 `Link_list` 类同时实现链表节点的存储、释放和链表的管理，但这种方式在链表的反转时就没法使用 `对象.方法()` 的形式实现了；
因此我就行了改进，`Link_list` 只用来管理链表，而单独用一个 `Link_node` 类来实现对链表节点的存储和释放。
改进过后的类如下：

```cpp
template <typename T>
class Link_node; // 类的提前声明

template <typename T>
class Link_list {
private:
  Link_node<T>* head;
  int length;
public:
  Link_list() : head(new Link_node<T>) {}
  Link_list(std::initializer_list<T> datas);
  ~Link_list() { delete this->head; }
// 其他成员函数此处省略
};

template <typename T>
class Link_node {
private:
  T data;
  Link_node<T>* next;
public:
  Link_node() : data(0), next(nullptr) {}
  Link_node(T data) : data(data), next(nullptr) {}
  Link_node(T data, Link_node<T>* next) : data(data), next(next) {}
  ~Link_node() { if (this->next != nullptr) delete this->next; };
public:
  friend class Link_list<T>;
};
```

## 2 四种方法  

### 2.1 迭代法

声明

```cpp
void reverse();
```

实现

```cpp
template <typename T>
void Link_list<T>::reverse() {
  if (this->head == nullptr || this->head->next == nullptr) return;

  Link_node<T>* beg = nullptr;
  auto mid = this->head;
  auto end = this->head->next;

  for (;;) {
    mid->next = beg;
    if (end == nullptr) break;
    beg = mid, mid = end, end = end->next;
  }

  this->head = mid;
}
```

### 2.2 头插法  

声明

```cpp
void reverse1();
```

实现

```cpp
template <typename T>
void Link_list<T>::reverse1() {
  if (this->head == nullptr || this->head->next == nullptr) return;

  auto old_head = this->head;
  this->head = nullptr;

  while (old_head != nullptr) {
    auto tmp = this->head;
    this->head = old_head;
    old_head = old_head->next;
    this->head->next = tmp;
  }
}
```

### 2.3 就地逆置法  

声明

```cpp
void reverse2();
```

实现

```cpp
template <typename T>
void Link_list<T>::reverse2() {
  if (this->head == nullptr || this->head->next == nullptr) return;

  Link_node<T>* beg = this->head;
  Link_node<T>* end = beg->next;

  while (end != nullptr) {
    beg->next = end->next;
    end->next = this->head;
    this->head = end;
    end = beg->next;
  }
}
```

### 2.4 递归法  

声明

```cpp
public:
  void reverse3() { this->head = reverse(this->head); }
private:
  Link_node<T>* reverse(Link_node<T>* head);
```

实现

```cpp
template <typename T>
Link_node<T>* Link_list<T>::reverse(Link_node<T>* head) {
  if (head == nullptr || head->next == nullptr) return head;

  auto new_head = reverse(head->next);
  head->next->next = head;
  head->next = nullptr;
  return new_head;
}
```

## 3 完整代码

### 3.1 类

```cpp
#include <iostream>
#include <initializer_list>

template <typename T>
class Link_node;

template <typename T>
class Link_list {
private:
  Link_node<T>* head;
  int length;

public:
  Link_list() : head(new Link_node<T>) {}
  Link_list(std::initializer_list<T> datas);
  ~Link_list() { delete this->head; }

public:
  T& operator[] (int index) {
    return this->get_node_by(index)->data;
  }
  const T& operator[] (int index) const {
    return this->get_node_by(index)->data;
  }

  void insert(T data, int index);
  void del(int index);

  void display();

  void reverse();
  void reverse1();
  void reverse2();
  void reverse3() { this->head = reverse(this->head); }
private:
  Link_node<T>* reverse(Link_node<T>* head);

private:
  Link_node<T>* get_node_by(int index) {
    auto tmp = this->head;

    for (int i = 0; i < index; ++i) {
      if (tmp->next == nullptr) {
        std::cout << "访问越界" << std::endl;
        exit(1);
      }
      tmp = tmp->next;
    };

    return tmp;
  }
};

template <typename T>
class Link_node {
private:
  T data;
  Link_node<T>* next;

public:
  Link_node() : data(0), next(nullptr) {}
  Link_node(T data) : data(data), next(nullptr) {}
  Link_node(T data, Link_node<T>* next) : data(data), next(next) {}
  ~Link_node() { if (this->next != nullptr) delete this->next; };

public:
  friend class Link_list<T>;
};


// Link_list<T> 方法实现
// 构造函数
template <typename T>
Link_list<T>::Link_list(std::initializer_list<T> datas) {
  if (datas.size() == 0) Link_list();
  else {
    auto tmp = this->head = new Link_node<T>(*datas.begin());

    for (auto p_data = datas.begin() + 1; p_data < datas.end(); ++p_data) {
      tmp->next = new Link_node<T>(*p_data);
      tmp = tmp->next;
    }
  }
}

// 插入  
template <typename T>
void Link_list<T>::insert(T data, int index) {
  auto parent_node = this->get_node_by(index - 1);
  parent_node->next = new Link_node<T>(data, parent_node->next);
}

// 删除
template <typename T>
void Link_list<T>::del(int index) {
  auto parent_node = this->get_node_by(index - 1);
  auto to_be_del = parent_node->next;
  if (to_be_del == nullptr) return;

  parent_node->next = to_be_del->next;
  to_be_del->next = nullptr;

  delete to_be_del;
}

// 输出所有元素
template <typename T>
void Link_list<T>::display() {
  auto tmp = this->head;

  while (tmp != nullptr) {
    std::cout << tmp->data << ' ';
    tmp = tmp->next;
  }

  std::cout << std::endl;
}

// 反转  
template <typename T>
void Link_list<T>::reverse() {
  if (this->head == nullptr || this->head->next == nullptr) return;

  Link_node<T>* beg = nullptr;
  auto mid = this->head;
  auto end = this->head->next;

  for (;;) {
    mid->next = beg;
    if (end == nullptr) break;
    beg = mid, mid = end, end = end->next;
  }

  this->head = mid;
}

// 头插法反转
template <typename T>
void Link_list<T>::reverse1() {
  if (this->head == nullptr || this->head->next == nullptr) return;

  auto old_head = this->head;
  this->head = nullptr;

  while (old_head != nullptr) {
    auto tmp = this->head;
    this->head = old_head;
    old_head = old_head->next;
    this->head->next = tmp;
  }
}

// 就地逆置法反转
template <typename T>
void Link_list<T>::reverse2() {
  if (this->head == nullptr || this->head->next == nullptr) return;

  Link_node<T>* beg = this->head;
  Link_node<T>* end = beg->next;

  while (end != nullptr) {
    beg->next = end->next;
    end->next = this->head;
    this->head = end;
    end = beg->next;
  }
}

// 递归反转
template <typename T>
Link_node<T>* Link_list<T>::reverse(Link_node<T>* head) {
  if (head == nullptr || head->next == nullptr) return head;

  auto new_head = reverse(head->next);
  head->next->next = head;
  head->next = nullptr;
  return new_head;
}
```

### 3.2 在 main 中测试  

```cpp
int main() {
  using namespace std;
  Link_list<int> list{ 1,2,3,4,5,6,7,8,9 };

  cout << "遍历输出:" << endl;
  list.display();

  cout << "把 6 改为 16" << endl;
  list[5] = 16;
  list.display();

  list.insert(11, 1);
  cout << "在 2 前面插入 11:" << endl;
  list.display();

  list.del(3);
  cout << "删除 3" << endl;
  list.display();

  list.reverse();
  cout << "反转" << endl;
  list.display();

  list.reverse1();
  cout << "再反转" << endl;
  list.display();

  list.reverse2();
  cout << "再反转" << endl;
  list.display();

  list.reverse3();
  cout << "再反转" << endl;
  list.display();

  return 0;
}
```

### 3.3 输出  

```bash
遍历输出:
1 2 3 4 5 6 7 8 9 
把 6 改为 16
1 2 3 4 5 16 7 8 9
在 2 前面插入 11:
1 11 2 3 4 5 16 7 8 9
删除 3
1 11 2 4 5 16 7 8 9
反转
9 8 7 16 5 4 2 11 1
再反转
1 11 2 4 5 16 7 8 9
再反转
9 8 7 16 5 4 2 11 1
再反转
1 11 2 4 5 16 7 8 9
```
