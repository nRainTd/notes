---
创建: 2025-10-03
tags:
---
# 目录  ^toc

- [[#目录  ^toc|目录]]
- [[#序言|序言]]
	- [[#1 本次培训规划|1 本次培训规划]]
		- [[#1.1 认知优先|1.1 认知优先]]
		- [[#1.2 结合代码|1.2 结合代码]]
		- [[#1.3 体验为主|1.3 体验为主]]
	- [[#2 什么是 Web 安全|2 什么是 Web 安全]]
- [[#从 STDIO 到 HTTP|从 STDIO 到 HTTP]]
	- [[#1 STDIO|1 STDIO]]
		- [[#1.1 引入|1.1 引入]]
		- [[#1.2 STDIO 通信|1.2 STDIO 通信]]
		- [[#1.3 基于 stdio 的文件管理服务器|1.3 基于 stdio 的文件管理服务器]]
	- [[#2 HTTP|2 HTTP]]
		- [[#2.1 从输入网址到显示页面|2.1 从输入网址到显示页面]]
		- [[#2.2 通信方式 - TCP|2.2 通信方式 - TCP]]
		- [[#2.3 通信格式 - HTTP|2.3 通信格式 - HTTP]]
			- [[#2.3.1 Method|2.3.1 Method]]
			- [[#2.3.2 Status Code|2.3.2 Status Code]]
			- [[#2.3.3 Content-Type 和 MIME|2.3.3 Content-Type 和 MIME]]
	- [[#3 apache2 和 nginx|3 apache2 和 nginx]]
		- [[#3.1 Web 服务器与 http 服务器|3.1 Web 服务器与 http 服务器]]
		- [[#3.2 静态服务器与动态服务器|3.2 静态服务器与动态服务器]]
		- [[#3.3 apache2/nginx 和后端服务器|3.3 apache2/nginx 和后端服务器]]
	- [[#4 PHP 后端与 Web 服务器通信|4 PHP 后端与 Web 服务器通信]]
		- [[#4.1 CGI|4.1 CGI]]
			- [[#4.1.1 通信方式|4.1.1 通信方式]]
			- [[#4.1.2 环境变量|4.1.2 环境变量]]
		- [[#4.2 Fast-CGI|4.2 Fast-CGI]]
		- [[#4.3 mod-php|4.3 mod-php]]
- [[#题目|题目]]
	- [[#1 入门|1 入门]]
		- [[#1.1 爆破密码|1.1 爆破密码]]
		- [[#1.2 文件上传|1.2 文件上传]]
		- [[#1.3 文件包含|1.3 文件包含]]
			- [[#1.3.1 `include`|1.3.1 `include`]]
			- [[#1.3.2 伪协议|1.3.2 伪协议]]
		- [[#1.4 RCE|1.4 RCE]]
	- [[#2 附加题|2 附加题]]
		- [[#2.1 try_catch|2.1 try_catch]]
		- [[#2.2 py_原型链污染|2.2 py_原型链污染]]


# 序言
## 1 本次培训规划
### 1.1 认知优先

先花时间为大家讲解 *基本认知* 类的知识，然后再演示几道入门例题。

> [!quote]
> 我们的任务是过河，但是没有桥或没有船就不能过。不解决桥或船的问题，过河就是一句空话。

其实入门阶段的 CTF 题难度不大的，都是些固定的套路，找点题目练练，每个人都能做出来；所以我们放到后面才讲解，而且只是给大家带进门(但讲的还是很细的)，不会给大家列举太多解题套路。

反而是一些认知类的东西，它能潜移默化地影响我们。很多时候我们学一种技术怎么都学不明白，很吃力，就是有一些认知我们不知道而已；一但有了这些认知，很多地方都会茅塞顿开，甚至会奇怪之前怎么就卡在了这么显而易见的点上。

另外就是，前面这些认知，就算大家招新赛很遗憾地没有进入社团，没有来学网安；之后大概率也是去学开发，而开发也是会用到这些知识的。

### 1.2 结合代码

> [!quote]
> Talk is cheap, show me the code.

很多技术，我们看它的文字描述，往往要像做语文阅读理解一样推敲半天才能搞清楚。而如果这项技术有代码实现，那就不一样了；代码是准确的、没有歧义的，我们只要能读懂代码，就能比读文字描述更准确地理解这项技术。

而本培训的一些地方，会用代码代替文字描述给大家讲解一些知识；大家也不用担心看不懂代码，我会给大家解释一些关键逻辑的。
而且我们的目的也不是教会大家学会敲具体的代码，而是让大家透过代码这面透镜，从更实在的角度建立对某些技术的认知。

### 1.3 体验为主

大家都是接受过 12 年教育的；在课堂上，为了让大家学会一个知识点，老师往往要翻来覆去地讲成百上千遍；在这种情况下，一节课能讲的知识点数量是不多的。

而本培训涉及的知识点放在一晚上讲，是一定没法让大家学会的。所以我们的目的不是学会并掌握，这在培训的语境下是不合适的(合适的语境是自己抱着教程硬啃，直到啃会为止；这是学技术的必经之路，没有捷径的)

所以我们的目的是带大家体验一遍基本知识体系，结合代码让大家对这一块建立一个基本的认知。等将来大家遇到具体问题时，再去真正地啃具体的知识。

所以上面说了，看不懂代码也不要紧；跟着我的解释去理解我给的代码的大致的、宏观的含义，然后建立起对相应技术的基本认知就可以了。

## 2 什么是 Web 安全

要知道 Web 安全，首先要知道什么是 Web 应用。

简单来说，Web 应用就是内容在浏览器等客户端(前端)呈现，逻辑代码等却在服务端运行的应用程序。像我们平时访问的网页就是一个 Web 应用的前端，而提供网页的服务器就是一个 Web 应用的后端。

而 Web 安全是一种技术，一种使 Web 应用提供的各种服务免受 *网络攻击*、*数据泄露* 与 *服务滥用* 等非法行为的技术。

简单地概括起来，Web 安全主要致力于：
1. 防止数据泄露(比如用户的住址、手机号等隐私信息)或被篡改
2. 控制访问权限，保障身份验证功能的可靠性，防止对特殊服务的未授权访问
3. 保障服务可用(防 ddos)

# 从 STDIO 到 HTTP
## 1 STDIO
### 1.1 引入

我们先看这样一个普通的 `c` 语言程序，保存到 `simple.c` 文件中
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
  for (int i = 0; i < argc; i++) {
    printf("收到参数%d: %s\n", i, argv[i]);
  }

  char str[24];
  printf("请输入: ");
  scanf("%24s", str);
  printf("你输入了: %s\n", str);

  return 0;
}
```

然后用 `gcc` 命令编译，之后运行 `./simple` 带上三个额外参数 `hello 123 456`
![[25_1_招新培训_Web-251003-215321.png]]

可以看到，按照源码里写的逻辑，程序向终端打印了收到的四个参数；分别是程序名本身 `./simple`、参数一 `hello`、参数二 `123`、和参数三 `456`；
接着，程序输出 `请输入: ` 提示，我们输入 `你好`，程序向我们输出了 `你输入了: 你好`，然后程序运行结束；
程序退出后，我们在终端中执行 `echo $?` 命令，获取到了 `main` 函数的返回值；返回 `0` 代表程序正常退出。

> [!question]
> 上面是一个最基本、最简单的 `c` 语言示例，每一个 `c` 语言的初学者都会写。
> 
> 但是，大家有想过，我们向 `printf()` 函数传入的参数是怎么被**发送**到终端上的呢？我们在终端上输入的内容按下回车后又是怎么被**发送**到 `c` 语言程序中被 `scanf()` 函数读取到的呢？
> 
> 答案是通过 `stdio` *通信*。

> [!tip]
> 至于如何通过 `main` 函数的参数获取到我们在终端传的参数，以及 `main` 的返回值如何被终端捕获并存在 `$?` 里(在 windows 的 powershell 和 cmd 中获取退出状态码的方式不太一样，我前面都是讲的 linux 下的 bash)，由于和下面内容无关，大家感兴趣的自行探索，这里不做说明
> 
> 另外为了减轻复杂度，这里我们不对 *终端* 和 `shell` 做区分，本文将始终用 *终端* 这个词来泛指二者的集合。

### 1.2 STDIO 通信

简单来说，`stdio` 是一套操作系统为在系统中运行的进程提供的与外界(其他程序)交互/通信的读写接口。

它通常有三个通道，分别是 `stdin`、`stdout` 和 `stderr`；当进程使用诸如 `printf` 等函数输出时，实际上是把数据写入 `stdout`；使用 `scanf` 等函数读取时，实际上是从 `stdin` 读取数据。

而由于上面示例中的程序是从终端启动的，终端会默认 *连接* 到程序的 `stdio`，所以我们可以在终端接收到程序通过 `printf` 向 `stdout` 发送的数据，也可以通过终端向程序的 `stdin` 发送数据。

![[stdio.excalidraw|1000]]

### 1.3 基于 stdio 的文件管理服务器

现在，让我们以 `stdio` 为 *通信方式*，自定义一个 *通信格式*；实现一个简单的文件管理服务器。

我们规定 *通信格式* 为：
```
方法 文件名 文件内容
```

方法包括：
1. `GET` 方法，用于读取文件内容
2. `PUT` 方法，用于创建新文件
3. `POST` 方法，用于更新文件
4. `DELETE` 方法，用于删除文件

实现的功能为：
服务器程序启动后，以终端作为客户端连接到服务器程序，终端可以以上述通信格式通过 `stdin` 向服务器程序发送请求，服务器程序根据请求内容执行对应操作，然后通过 `stdout` 把执行结果响应给终端。

比如，在终端输入下面内容，通过 `stdin` 发送到服务器程序
```
GET test.txt
```

服务器程序去指定目录下读取文件内容，并把内容作为响应发送到 `stdout` 被终端读取，比如终端会收到：
```
this is a test file
```

实现如下：
```js
const process = require('process');
const path = require('path');
const fs = require('fs');

// 获得 stdin 和 stdout 接口
const { stdin, stdout } = process;
// 设置文件存储基准目录
const baseDir = path.resolve(__dirname, 'static');
// 如果不存在则创建目录
if (!fs.existsSync(baseDir)) {
  fs.mkdirSync(baseDir);
}

// 向 stdout 写入提示符
stdout.write('req: ');

// 监听 stdin 接口
stdin.on('data', data => {
  // 传入 payload 返回响应的辅助函数
  function response(payload) {
    stdout.write(`res: ${payload}\nreq: `);
  }

  // 解析请求
  const [method, filename, ...rest] = data.toString().trim().split(' ');

  if (!filename) {
    response('格式错误');
    return;
  }
  const content = rest.join(' ');
  // 待处理的文件具体路径
  const filePath = path.join(baseDir, filename);
  // 待处理文件所在目录
  const fileDir = path.dirname(filePath);

  // 存有对所有 method 的处理函数的对象
  const handlers = {
    get() {
      try {
        if (!fs.existsSync(filePath)) {
          throw '文件不存在';
        }
        const res = fs.readFileSync(filePath);
        response(res);
      } catch (err) {
        response(`读取文件失败\n${err}`);
      }
    },
    post() {
      try {
        if (!fs.existsSync(filePath)) throw '文件不存在';
        fs.appendFileSync(filePath, content);
        response('更新成功');
      } catch (err) {
        response(`更新文件失败\n${err}`);
      }
    },
    put() {
      try {
        if (!fs.existsSync(fileDir)) {
          fs.mkdirSync(fileDir);
        }
        fs.writeFileSync(filePath, content);
        response('创建成功');
      } catch (err) {
        response(`创建文件失败\n${err}`);
      }
    },
    delete() {
      try {
        fs.unlinkSync(filePath);
        response('删除成功');
      } catch (err) {
        response(`删除失败\n${err}`);
      }
    },
  };

  try {
    // 根据不同的方法方法调用对应的处理函数
    handlers[method.toLowerCase()]();
  } catch (_) {
    response('方法不存在');
  }
});
```

## 2 HTTP
### 2.1 从输入网址到显示页面

大家有没有想过，从我们在浏览器输入一个网址(或点击一个超链接，本质上还是用网址访问的)到我们看到网页的界面，这中间发生了什么？

其实这是个能拓展很多内容的议题，也是比较经典的面试题（原因是这个问题的答案很有层次，水平够的人能讲的很细很细，讲到很深的层次；而水平不够的只能回答个大概，层次很浅）
这个问题，至少能从三个方面来讲；一个是 *网络通信* 的知识、一个是 *服务端处理 http 请求* 的知识，还有就是 *浏览器渲染原理* 方面的知识；这三个方便也是既可以泛泛而谈也可以讲的很细的。所以很能区分出不同人的水平。

这里我们肯定不会讲的那么细，只是大概提一下流程，给一个直观的感觉即可。

一个比较浅显的 *请求/响应* 过程如图所示，下面将结合例子具体讲解
![[http.excalidraw | 1000]]

这里我们用一个伪代码来描述一下上述过程浏览器端的逻辑

```c
void send_http_request(char *url) { // url = 'http://example.com:80/'
    char *host = get_host_from(url) // host = example.com
    int port = get_port_from(url) // port = 80
    
    if (not_ip(host)) host = dns_query(host)
    
    char *request_text = generate_request(url)
    
    char *response = tcp_send(host, port, request_text)
    
    render_page(response)
}
```

1. 我们在浏览器输入一个网址，然后浏览器调用 `send_http_request(url)` 函数，把我们输入的网址作为参数传入。
2. 解析 `url` 获得它的 `host` 和 `port`
3. 如果 url 中主机地址部分是域名而非 ip 地址，则会先向 DNS 服务器发送一个 dns 查询，查询到域名对应的 ip，保存到变量 `host` 中
4. 接着，浏览器会帮我们生成一个 `http` 请求报文，保存到 `request_text` 变量中
5. 然后，调用负责 `tcp` 协议的函数，把 *主机地址*，*端口号*、*http 请求报文* (即 `host` `port` `request_text`)作为参数传入这个函数；服务器响应后，拿到 `response` 作为返回值
6. 接着，调用 `render_page(response)` 函数把响应的响应体渲染到页面上。

### 2.2 通信方式 - TCP

这里再用一个类比提一下第 `5` 步传入主机地址和端口号的作用。

简单来说，通过 `ip` 地址，我们能使得我们的请求被发送到目标服务器；而 `port` 端口号则是使得我们的请求能被发送到服务器上的特定程序。

这就像我们点外卖，*“某小区某号楼某单元”* 只能使得外面被送到一栋楼(就像 `ip` 地址可以找到某台服务器)；
可一栋楼有很多住户，每个住户都会有个房间号；要想送到我们门口，就得报房间号，比如 `502`，这样外卖就能直接送到我们手里了(就像一台服务器上运行有很多程序，每个程序都 *可以* 占用一个端口，通过特定端口就能把网络包发送到占用了这个端口的程序)。

### 2.3 通信格式 - HTTP

下面，让我们用 `nodejs` 自带的 `http` 库写一个基本的 `web` 服务器，来讲一讲 `http` 协议

```js
const http = require('http');
const fs = require('fs');
const path = require('path');
const { log } = console;

const server = http.createServer(function (req, res) {
  log('=========================================');
  log(`方法: ${req.method}`);
  log(`Path: ${req.url}`);
  log(`版本: ${req.httpVersion}`);
  log(`Host: ${req.headers.host}`);

  if (req.method === 'GET') {
    GET_Handler();
  } else if (req.method === 'POST') {
    POST_Handler();
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('不支持的方法:', req.method);
  }

  function GET_Handler() {
    if (req.url === '/') {
      res.writeHead(302, { Location: '/index.html' });
      res.end();
      // const indexPage = path.join(__dirname, 'static/index.html');
      // res.writeHead(200, { 'Content-Type': 'text/html' });
      // res.end(fs.readFileSync(indexPage));
    } else if (req.url.includes('dynamic')) {
      res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
      const queryString = require('querystring').parse(
        req.url.split('?')[1] || ''
      );
      res.end('你好' + (queryString['name'] || '世界'));
    } else {
      try {
        const filePath = path.join(__dirname, 'static', req.url);
        res.end(fs.readFileSync(filePath));
        // fs.readFile(filePath, (err, data) => {
        //   res.end(data);
        // });
      } catch (err) {
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('404 Not Found');
        // res.writeHead(200, { 'Content-Type': 'text/html' });
        // const file = path.join(__dirname, 'static/404.html');
        // res.end(fs.readFileSync(file));
      }
    }
  }

  function POST_Handler() {
    let body = '';
    req.on('data', data => {
      body += data.toString();
    });
    req.on('end', () => {
      log('POST BODY:');
      log('原始数据:', body);

      let parsedBody;
      if (req.headers['content-type'] === 'application/x-www-form-urlencoded') {
        parsedBody = require('querystring').parse(body);
      } else if (req.headers['content-type'] === 'application/json') {
        parsedBody = JSON.parse(body);
      } else {
        parsedBody = body;
      }
      log('解析后:', parsedBody);
      res.write('success\n');
      res.end(JSON.stringify(parsedBody));
    });
  }
});

server.listen(81, '0.0.0.0', () => {
  console.log(`server is listening on http://localhost:81`);
});
```

使用 `node server.js` 启动程序，然后访问服务器地址
![[25_1_招新培训_Web-251010-150431.png]]

同时用 `yakit` 抓包，抓到请求报文和响应报文如下图(我标注了各部分的含义，对应英文也可以看另外两张图)
![[25_1_招新培训_Web-251010-151559.png]]

![](https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-request.svg)

![](https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-response.svg)

#### 2.3.1 Method

对于请求方法，我们这里只介绍 `GET` 和 `POST` 这两个方法，`web` 服务器基本都会支持这两个方法；而其他的方法不常用，一般 `web` 服务器也不会处理那些方法，也就相当于不支持。

想了解更多的 `HTTP` 请求 `Method` 可以去 [这个链接](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Methods) 了解
![[25_1_招新培训_Web-251010-152513.png]]

实际上，不同的 `Method` 的作用只是 *语义上* 的，是 *约定俗成* 的规范；实际的作用得看服务器的实现。服务器接收到的 `http` 请求报文只是一个文本，从文本中解析 `Method` 后，对不同 `Method` 的具体处理方式是服务器决定的，事实上，服务器完全可以不按照规范处理。

大概地，对于 `GET` 和 `POST` 方法，*语义上* 服务器会做如下处理：
1. `GET` 方法表示从服务器获取数据，服务 器收到 `GET` 方法后主要根据 `Path` `Headers` `QueryString` 等内容来判断该返回什么数据给前端；此方法一般不会改变服务器上的资源；一般用于获取 `html/css/js` 的前端源码、`png/svg/mp4` 等媒体资源，也可以通过 `QueryString` 发送少量数据。
2. `POST` 方法表示向服务器传递数据，一般会把需要传输的数据放在 `Body` 请求体中(一般会用 `Content-Type` 头部指定 `Body` 中数据的类型)，但服务器也可以读到 `Path` `Headers` `QueryString` 等信息；一般用于登录验证中发送账号密码、购物网站上提交订单信息等。

#### 2.3.2 Status Code

响应状态码，这个也只是约定而已；不过由于有些特定状态码会触发浏览器的特定行为(毕竟浏览器一般是遵守规范的)/有些状态码会触发代理服务器的特定行为，比如 `302` 会触发浏览器的重定向，使得浏览器去访问 `Location` 头部指定的地址，所以一般服务器也会遵守这些会触发特定行为的规范。

不过，也不是全部遵守，比如有些服务器就不会返回 `404` 这个表示请求页面不存在的状态码，而是页面存不存在都返回 `200`，而页面不存在通过返回一个 `404.html` 页面来告诉用户。

我们只需要知道 `200` 表示请求成功、`302` 表示重定向、`404` 表示请求资源不存在就行了；其他的遇到了再去 [文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status) 里查就行了，而且具体的行为还得看服务器和浏览器的实现(浏览器其实也会在一些细节上不按照规范来)

![[25_1_招新培训_Web-251010-160914.png]]

#### 2.3.3 Content-Type 和 MIME

下面是我当时第一次接触 `Content-Type` 时记的笔记(写的很拉跨就是了)
![[upload#2.2 拾穗]]

简单来说，`Content-Type` 是一个 `Http` 请求/响应通用的一个 `Header`，用于描述请求/响应体内数据的类型；
而 `MIME` 是 `Content-Type` 的值的格式规范，用于描述一串数据的类型，在 `Content-Type` 中显然就是用来描述 `Body` 中数据的类型了。

对于请求，在表单提交中会用到 `application/json` `application/x-www-form-urlencoded` `multipart/form-data;`；在文件上传中会用到 `multipart/form-data;`(这个稍后讲到文件上传的题目时再讲)等

对于响应，返回的响应体的类型可能是 `text/plain`(纯文本)、`text/html`(页面)、`text/javascript`(前端运行的 `js` 代码)、`image/png`(图片)、`video/mp4`(视频) 等

## 3 apache2 和 nginx
### 3.1 Web 服务器与 http 服务器

下图是 [MDN](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_web_server) 对 Web 服务器的定义
![[25_1_招新培训_Web-251010-194649.png]]

简单来说，Http 服务器指的是能够理解 Http 请求报文，能够生成 Http 响应报文的软件；

而对于 Web 服务器，当它代指硬件时，指的是提供 Web 服务的、运行有 Web 服务器软件的可通过公网访问的计算机；当它指代软件时，指的是在 Http 服务器软件功能基础上，能够访问到托管资源的软件。

### 3.2 静态服务器与动态服务器

还是如下图 [MDN](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_web_server) 的定义
![[25_1_招新培训_Web-251010-195551.png]]

简单来说，静态服务器就是只提供静态文件访问的 Web 服务器；
而动态服务器除了访问静态文件，还可以动态地生成数据(所谓动态，即情况不同，返回数据不同；比如从数据库读取的数据，由于数据库会不断更新，所以从同一个地方读取的数据可能会发生改变；或者可以理解成一个函数，函数的输出(响应)是根据输入(请求)来生成的；总之就是响应的数据不是躺在文件夹中不动的，而是运行一段代码后产生的数据作为响应)

### 3.3 apache2/nginx 和后端服务器

apache2 和 nginx 其实就是现成的 Web 服务器而已，默认只能提供文件访问服务，也就是静态 Web 服务器；

> [!help]
> 演示静态服务器

但通过配置反向代理、CGI、FastCGI 等，可以把对动态路由的请求交给后端程序去动态处理，就可以把 apache2/nginx 拓展为动态服务器。

## 4 PHP 后端与 Web 服务器通信

如上文所述，我们可以配置 PHP 作为后端把静态的 apache2/nginx Web 服务器拓展为动态 Web 服务器，下面我们将用一段简单的 `php` 演示其功能

```php
<?php
if (isset($_GET['name'])) {
  echo '你好' . $_GET['name'];
} else {
  echo '你好世界';
}

echo '<br />';

if (isset($_POST['content'])) {
  echo '你输入的内容是：' . $_POST['content'];
} else {
  echo '你没有输入内容';
}
```

> [!Help]
> 用 `php` 演示动态 Web 服务器

前面我们已经知道我们配置了静态目录 `/var/www/html/`，然后我们假设我们已经配置好了 `php` 作为 Web 服务器的后端(具体怎么配置的这里暂且按下不表)

这时，我们删掉原来的 `/var/www/html/index.html`；创建一个文件 `/var/www/html/index.php`，然后写入上述 php 代码。

接着，我们访问 `http://172.23.201.159/index.php`，会发现 `php` 文件被运行了，然后我们在前端收到的是 `php` 代码中 `echo` 的内容
![[25_1_招新培训_Web-251010-220333.png]]

![[25_1_招新培训_Web-251010-220346.png]]

为什么我们明明访问的是 `index.php` 文件，但返回的不是 `index.php` 的文件内容，而是 `index.php` 代码的执行结果呢？

其实是因为我们对 Web 服务器(apache2/ngnix)进行了配置，使得它遇到后缀为 `.php` 的文件，就不会返回文件本身的内容，而是调用 `php` 解释器运行这个文件，返回文件运行的结果。

但是在代码中我们看到了，php 可以通过 `$_GET['xxx']` `$_POST['xxx']` 的方式获取到 Http 请求的信息，就像 `nodejs` 中用 `req.method` 获取信息一样。

在 `nodejs` 中，其本身就是 `http` 服务器，Http 报文被解析后直接把解析结果保存在 `req` 变量中传递给回调函数供使用；可是，在 `php` 中，`php` 本身并不充当 `http` 服务器、它只会执行后端逻辑；那么，apache2 等 Web 服务器解析后的 Http 数据又是如何传递给 `php` 的呢？

答案是通信！毕竟 Web 服务器和 `php` 是两个分开来的程序(当然 `apache2` 的 `mod-php` 除外)，所以它们之间传递数据肯定得通过通信。

下面，就让我们介绍两种 Web 服务器与 `php` 的通信协议。

### 4.1 CGI
#### 4.1.1 通信方式

CGI(Common Gateway Interface，通用网关接口)，是比较古早的 Web 服务器与后端应用的通信方式

它的基本思路就是，当前端对 `/xxx.php` 等在 Web 服务器配置过的文件请求时，Web 服务器会创建一个子进程去调用配置好的解释器去运行这个文件，解析好的 Http 报文的 `Method` `Path` `Headers` 等信息会通过环境变量的方式传递给这个子进程，而对于 `POST` 等请求的 `Body`，则是通过 `stdin` 传送给子进程；当子进程执行完文件后，执行的结果会通过 `stdout` 返回给 Web 服务器；Web 服务器解析这个结果并构造出 Http 响应然后返回给前端。

#### 4.1.2 环境变量

关于环境变量，这里就简单演示一下，不做过多概念上的说明了；大家有个直观的体验即可

在终端中，我们使用下面命令设置一个环境变量(只在当前终端(shell)有效，重开一个终端后就相当于没设置)

```sh
export env_var='this is a env var'
```

然后，我们可以使用 `echo $env_var` 看到我们设置的环境变量
![[25_1_招新培训_Web-251010-224338.png]]

当然，我们也可以编写一个程序，在程序中读取 `env_var` 环境变量；
只要在设置了 `env_var` 的终端(其实是 `shell`，这里不做区分)运行的程序，都是它的一个子进程，直接继承了它的所有环境变量，因此能读取到之前设置的 `env_var`。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  const char *env = getenv("env_var");
  printf("%s\n", env);

  return 0;
}
```

在上面的 `c` 语言程序中，我们使用 `getenv("env_var")` 读取环境变量 `env_var` 并输出它
![[25_1_招新培训_Web-251010-224851.png]]

可以看到正常输出了

### 4.2 Fast-CGI

但是传统的 CGI 方式有个缺点，就是每当 Web 服务器接收到一个请求，都会开一个子进程；请求结束后再关闭这个进程。
但我们知道，进程的开启和关闭是很耗时的，过去的站点访问的人不多还好；现代的站点访问量是海量的，这种有一个请求就现开一个进制的机制无疑是不可行的；于是，`CGI` 的升级版 `FastCGI` 就孕育而生了。

在 `php` 中，`php-fpm` 是 `FastCGI` 协议在 `php` 方面的具体实现，它实际上是一个进程管理器(`PHP FastCGI Process Manager`)。

下面(紫色背景的部分)是我学这个的时候记的笔记，当然这个难度是比我这里要讲的高的，这里只是贴一下，可以直接跳过的：
![[file_put_content打php-fpm#3.1 FastCGI 与 PHP-FPM]]
![[file_put_content打php-fpm#3.2 FastCGI 的数据结构]]

当启动 `php-fpm` 时，它会自行开启几个 `php` 解释器进程常驻内存；当接收到 Web 服务器传输过来的请求信息时，它会把这个请求信息分配给空闲的 `php` 解释器，让解释器去执行请求信息中指定的 `php` 文件，解释器执行完成后的结果交到 `php-fpm` 手里由它返回给 Web 服务器；执行完成后，`php` 解释器不会退出，而是处于空闲待机状态等待 `php-fpm` 分配任务。

Web 服务器和 `php-fpm` 之间的使用 `FastCGI` 协议进行通信；与 `CGI` 协议使用 `stdio` 和环境变量通信不同，`FastCGI` 使用 `TCP` 或 `Unix Domain Socket` 进行通信；

`TCP` 通信讲 `Http` 的时候已经讲过，只不过这次是 Web 服务器通过本机的 `9000`(一般是) 端口和 `php-fpm` 进行通信；而 `Unix Domain Socket` 是本机程序进程间通信的一种方式，它由于不走网络栈，所以比 `TCP` 性能要高一些，但效果和 `TCP` 通信差不多，这里就略过了。

而 `FastCGI` 的通信格式如我上文紫色背景内的笔记所示，感兴趣可以看看，这里就不讲了。

其实我在这里讲 `FastCGI` 等的目的只是让大家对 *为什么明明访问的是 `xxx.php` 文件，可没有返回这个文件而是执行这个文件* 这点有个直观的感受而已，不至于摸不着头脑。

这里总结一下，不论是 `CGI` 还是 `FastCGI` 的方式，之所以访问 `xxx.php` 却是执行它然后返回它的运行结果，是因为在 Web 服务器中我们做了特殊的配置，使得 Web 服务器遇到 `.php` 等后缀时，不会返回文件内容，而是会通过 `CGI/FastCGI` 协议把请求信息传递给对应文件的执行环境，让文件在执行中处理它们，然后把文件的执行结果包装成响应返回。

### 4.3 mod-php

这里再补充一点，就是对于 `apache2` 来说，这个 Web 服务器是自带 `mod-php` 模块的。所以我们可以直接启用 `php` 模块，然后对 `.php` 等文件的请求，就会自动把文件和请求信息一块交给 `mod-php` 模块去执行了。
不过 `nginx` 没有；还有就是 `mod-php` 也是有性能问题的，不如 `php-fpm`，但这里就不做过多解释了。

# 题目
## 1 入门
### 1.1 爆破密码

这个没啥好说的，就是用爆破工具(`bp` `yakit` `hydra`)去把密码字典中的所有密码都尝试一遍，直到试出正确的密码为止。

由于 Http 是比较宽泛的协议，只做基本的语义上的约定，所以 Web 服务器验证密码的方式是多种多样的。

用的比较多的是用 `POST` 请求在 `Body` 中带上 `user=admin&password=123456` 或 `{"user": "admin", "password": "123456"}`，当然也有把这些信息放在 `QueryString` 或是 `Cookie` 的做法。

Http 原生的身份验证方案通过 `WWW-Authenticate`(响应头部)和 `Authorization`(请求头部)实现，它支持多种验证类型，不过在实际使用中，基本不会使用原生的方案。

下面就看一个 `Authorization Basic` 验证的 `CTF` 题吧。

我们访问题目地址，直接弹出身份验证的弹窗
![[25_1_招新培训_Web-251012-115423.png]]

抓个包看看

第一次请求时，服务器返回的响应带了 `WWW-Authenticate` 头部，要求使用 `Basic` 方式验证身份
![[25_1_招新培训_Web-251012-115531.png]]

我们随便输个账号密码，抓第二个包看看
可以看到，我们输的账号密码，用 `:` 拼接起来后进行了 `Base64` 编码后 通过 `Authorization` 头部发送给了服务器，但由于密码不对，所以服务器又返回了 `401 Unauthorized` 和 `WWW-Authenticate` 头部要求验证
![[25_1_招新培训_Web-251012-115805.png]]

我们这里直接爆破一下密码，每次请求从密码字典中取出一项，拼接到 `admin:` 后面，并把它们整体用 `base64` 编码，放到 `Authorization` 头部中，然后在爆破结果中找到 `200` 的响应
![[25_1_招新培训_Web-251012-120159.png]]

### 1.2 文件上传

文件上传这个词大家都能理解，就是前端能向后端上传文件，比如我们上传文件到网盘、上传文件到 QQ 群、甚至在算法题平台上传代码文件(其实直接在平台上写代码再提交在抽象层面也属于文件上传)；

而文件上传漏洞，之所以会产生，关键的一点就在于我们上传的文件在某种条件下可以被服务器执行，并且有能力执行危险操作。

还是拿算法题平台举例，由于要运行选手写的代码拿到运行结果才能判断选手代码对错，所以天然就会运行上传的文件，这就有可能产生文件上传漏洞；当然一般算法平台都是把代码放到严格隔离的环境中运行的，而且对代码文件本身的内容也会有严格的过滤，所以成熟的算法平台基本不会有文件上传漏洞。其实我们 `CTF` 比赛的 Web 题和渗透题也是开一个隔离的环境(`docker` 容器)给大家去做题的，以保证对题目环境造成的影响不会殃及平台服务器本身。

在 php 题目中，上传的文件可能被执行的原因，就是上面我们讲过的，Web 目录下，`.php` 等后缀的文件在访问时会被执行；因此，如果我们能向 Web 目录上传 `.php` 文件，里面写有危险代码，那么我们就能够通过访问这个文件来执行它。

下面以一个经典的题目为例：

是一个简单的文件上传页面
![[25_1_招新培训_Web-251013-102046.png]]

我们上传一个 `php` 文件，但回显只能上传 `txt` 文件
![[25_1_招新培训_Web-251013-102250.png]]

上传一个 `test.txt` 文件，回显了文件的保存位置
![[25_1_招新培训_Web-251013-102311.png]]

我们访问，可以看到回显了文件内容
![[25_1_招新培训_Web-251013-102323.png]]

抓个包看看请求体，各部分含义如图所示
![[25_1_招新培训_Web-251013-103138.png]]

现在我们的目的是上传 `.php` 文件，其实就是绕过服务器对文件类型的判断；而判断文件类型，无非就三个依据：文件后缀、`Content-Type`、文件内容，我们从这三个方面着手就行了

这里首先排除文件内容；一般 `CTF` 题对文件内容的过滤都是检测 `<?php` 等关键字符、或者是判断有没有图片文件头；而尝试的话，只要上传的是 `txt` 文件，那么文件里写 `php` 代码也不会被过滤。

然后就是文件后缀和 `Content-Type` 了，这题确实是这两个在影响，先说解题方法，再给出解释：

我们只要在 `.txt` 后面加上 `.php`，然后确保 `Content-Type` 为 `text/plain` 就行了
![[25_1_招新培训_Web-251013-104838.png]]

接着，我们访问我们上传的文件，成功获得 `flag`
![[25_1_招新培训_Web-251013-105913.png]]

至于为什么这么做，从做题的角度来说，这是一种经验(套路)。从原理的角度来说，源码里对文件类型的判断不够严谨，通过源码就能解释清楚(不过文件上传的题一般不会给源码，所以还是要用各种套路去尝试)

这题的源码长这样：

```php
<?php
error_reporting(0);

if (isset($_FILES['file'])) {
  $file = $_FILES['file'];
  if ($file['error']) {
    die('上传失败');
  }

  $fileName = $file['name'];
  $fileContentType = $file['type'];

  if (strpos($fileName, '.txt') === false || $fileContentType !== 'text/plain') {
    die('只能上传txt文件');
  } else {
    $uploadDir = 'uploads';
    $filePath = $uploadDir . '/' . $fileName;
    if (!is_dir($uploadDir)) {
      mkdir($uploadDir);
    }

    $res = move_uploaded_file($file['tmp_name'], $filePath);
    if ($res) {
      echo '上传成功，文件保存在：' . $filePath;
    } else {
      echo '上传失败';
    }
  }
}
```

判断文件类型的逻辑中，它只判断了文件名中有没有 `.txt` 字眼，以及 `Content-Type` 是不是 `text/plain` 所以很容易用上面的方法绕过的。
![[25_1_招新培训_Web-251013-110323.png]]

当然，如果源码不是判断文件名中是否有 `.txt`；而是严格过滤了文件后缀，比如 `.php` 等关键词就不能出现在文件名中，那我们还可以尝试 `pht` `phtml` 等其他 `php` 文件的后缀，但须要在配置中配置了其他后缀才可以；
对于这种黑名单文件后缀过滤来说，如果 Web 服务器是 `apache2`，那么我们还可以先上传一个 `.htaccess` 文件，内容为：

```.htaccess
AddHandler application/x-httpd-php .txt
```

这样一来,在有 `.htaccess` 的目录下，`.txt` 后缀的文件就会被当作 `php` 文件去执行；
然后我们再上传写有 `php` 危险代码的 `txt` 文件，访问这个文件就能使里面的代码被执行了。

### 1.3 文件包含

这个我们就以上次的周三的体验工坊的题目为例

```php
<?php
// flag 在 $FLAG 环境变量
highlight_file(__FILE__);

if (isset($_GET['file'])) {
      include $_GET['file'];
}
```

这里先引用一下当时写的题解(紫色背景部分)，但我们这里不完全按照这个讲
![[ctf体验工坊web题解#6 ez_include]]

#### 1.3.1 `include`

`include` 其实可以简单理解为把指定的文件的内容替换到 `include` 原本的位置去执行。

当然，具体来说，还分两种情况：一是文件内容有 `<?php` 开头接上 `php` 代码的结构，那就是执行里面的 `php` 代码，符合上句话说的。
但如果文件内容没有 `<?php` 结构，那就原样回显文件内容，而不是执行文件中的 `php` 代码。

多说无益，我们直接看代码。我们有 `main.php` 和 `other.php` 两个文件

```php
<?php
// main.php
include("./other.php");
```

```php
123
<?php
// other.php
echo 456;
?>
789
```

我们执行 `main.php` 会输出啥？答案是 `123456789`。
这符合我上面说的，遇到普通的文本就直接输出；遇到 `<?php` 之后跟 `php` 代码的，就直接执行 `php` 代码。

#### 1.3.2 伪协议

回到上面的题目，题目里说了，`flag` 在环境变量 `$FLAG` 里，因此我们需要能够执行 `php` 代码 `system("echo $FLAG");`。
但是，上面我们又说了，必须得有现成的 `php` 代码文件给我们包含才能执行代码，否则只是输出文件内容(我们的 `flag` 不是保存在 `/flag` 等具体文件中的，因此也没法通过直接包含 `include("/flag")` 的方式读取 `flag`)；就算我们知道服务器上一些 `php` 文件的路径，我们也没法控制里面的内容为 `system("echo $FLAG");`，所以该如何是好呢。

这里就要用到 `php` 伪协议了。

我们知道，`include` 接收一个文件路径参数，然后去读取到对应文件的内容并根据上述规则去处理里面的内容(回显或执行)；具体来说，比如 `include("/var/www/html/other.php")`，就是读取这个文件的内容并执行代码。

这时候我们再看看我们访问 `http://xxx.xxx/index.html`，从抽象的角度看，不也是让浏览器获取到 `index.html` 文件并处理(渲染页面)么？况且 `/var/www/html/other.php` 和 `http://xxx.xxx/index.html` 长得挺像的不是么，而且文件路径也可以写成 `file:///var/www/html/other.php` 这就更像了。其实，不论 `http://...` 还是 `file://...`(... 是省略号)，其实都叫 `url`(统一资源定位符)，用于获取到一个具体的资源(文件)。

事实上，如果 `php` 开启了 `allow_url_include` 选项(这个选项默认关闭)，就可以远程包含其他服务器上的文件，因此我们直接在自己的服务器上编写恶意代码，然后让靶机通过 `http://` 包含我们服务器上的恶意代码文件，就能成功执行我们想要执行的代码，获得 `flag`。

当然，这个方法不是特别方便，毕竟我们得有一台自己的服务器；而且还要搭一个 Web 服务器(这个还是比较方便的，用 `python -m http.server` 就行)。

所以就要引入伪协议，名字叫伪协议，其实叫伪 `url` 更容易理解；它是从 `http://...` `file://...` `ftp://...` 等具体的真 `url` 拓展出来的一种多功能的伪 `url`；这里怎么描述都不直观，我们直接演示功能就很清晰明了了。

比如 `data://text/plain,<?php system('echo $FLAG');?>`，就表示访问这个伪 `url` 获取到的资源就是这个 `url` 本体上的字符串 `<?php system('echo $FLAG');?>`；

再比如 `php://filter/read=convert.base64-encode/resource=test.txt` 就表示读取 `test.txt` 这个文件 `base64` 编码后的数据，而不是文件原来的内容。

而放到这里，我们的 payload `?file=data://text/plain,<?php system('echo $FLAG');?>` 就很好解释了，就是让 `include` 读到 `<?php system('echo $FLAG');?>` 并执行罢了。

### 1.4 RCE

题目长这样：
![[25_1_招新培训_Web-251013-210024.png]]

给了源码

```php
<?php
highlight_file(__FILE__);

system("ls " . $_GET['dir']);

echo <<<HTML
<!DOCTYPE html>
<html>
<head>
<title>ls</title>
</head>
<body>
<form action="index.php" method="get">
<input type="text" name="dir" />
<input type="submit" value="submit" />
</form>
</body>
</html>
HTML;
```

然后下面有个输入框，是最后一个 `echo` 输出的 `html` 页面渲染出的，当点击按钮后，我们输入的内容会被拼接到 `system` 函数的参数中，比如我们输入 `/`，最终 `system("ls /");` 会被执行，输出根目录下文件名。

然后我们会发现在根目录下有 `/flag`
![[25_1_招新培训_Web-251013-210047.png]]

我们用 `;` 号直接结束前面的 `ls` 命令，然后后面接上 `cat /flag`；最后 payload 为 `;cat /flag`，其实到服务器执行的就是 `ls; cat /flag`，最后会输出两个命令的结果。
![[25_1_招新培训_Web-251013-210300.png]]


## 2 附加题

主要是带大家见识见识稍微有点难度的题目长啥样，所以就不不写文档了。

### 2.1 try_catch

```
D:\CTFTEST\米好2025\第二阶段赛题文件\cc969a223ebd002e90a4b0bcb08de4ae
```

### 2.2 py_原型链污染

原本计划讲的，但又想到这题就算是带大家见识，也要解释一堆编程语言的特性，很费时间；所以就去掉了。

当然，我也写过一篇 py 原型链污染的笔记；之后我可以发群里。
不过大家大概看不太明白，因为这是我写给我自己看的笔记，不会解释过多细节。不过，大家仍然可以从里面参考参考如何记笔记，因为你们以后进入社团也是要每周都记学习笔记的。

